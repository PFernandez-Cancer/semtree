}
treeDivergence <- function(tree1, tree2, data, divergence=klsym) {
# similarity of two trees, sampling-based
#  person.row <- data[sample(1:nrow(data),size = 1),]
trav1<-traverse(tree1, data)
trav2<-traverse(tree2, data)
precomputeDist <- list()
dds <- rep(NA, nrow(data))
for (i in 1:nrow(data)) {
nodeid1 <- trav1[i]
nodeid2 <- trav2[i]
key <- paste0(nodeid1,";",nodeid2)
model1 <- semtree::getNodeById(tree1, nodeid1)$model
model2 <- semtree::getNodeById(tree2, nodeid2)$model
# obtain difference of models (independent of the sample value?)
if (!is.null(precomputeDist[[key]])) {
diff <- precomputeDist[[key]]
} else {
cov1 <- getExpectedCovariance(model1)
cov2 <- getExpectedCovariance(model2)
mu1 <- t(getExpectedMean(model1))
mu2 <- t(getExpectedMean(model2))
diff <- divergence(mu1, cov1, mu2, cov2)
precomputeDist[[key]] <- diff
}
dds[i] <- diff
}
return(mean(dds))
}
diversityMatrix <- function(forest, divergence=klsym, showProgressBar=TRUE) {
trees <- forest$forest
ntree <- length(trees)
distmat <- matrix(NA,nrow=ntree,ncol=ntree)
if (showProgressBar)
pb <- utils::txtProgressBar(min=0,max= (ntree^2-ntree)/2)
cnt <- 1
for (i in 1:ntree) {
for (j in i:ntree) {
if (i==j) {distmat[i,j]<-0; next;}
tsi <- NA
tryCatch({
tsi <- treeDivergence(trees[[i]],trees[[j]], forest$data,
divergence=divergence)
})
distmat[i,j] <- distmat[j,i] <- tsi
if (showProgressBar)
setTxtProgressBar(pb, cnt)
cnt <- cnt + 1
}
}
if (showProgressBar)
close(pb)
class(distmat) <- "diversityMatrix"
return(distmat)
}
a <- Sys.time()
D <- diversityMatrix(fr)
Sys.time()-a
lineprof(treeDivergence(forest$forest[[1]],forest$forest[[2]],forest$data))
l
l <- lineprof(treeDivergence(forest$forest[[1]],forest$forest[[2]],forest$data))
l
l
getNodeN
getNodeById(forest$forest[[1]],1)
getNodeById(forest$forest[[1]],4)
getNodeById(forest$forest[[1]],2)
tree <- forest$forest[[3]]
tree
id <- 4
l <- getNodeById(tree$left_child, id);
r <- getNodeById(tree$right_child ,id);
l
r
c()
getNodeById <-
function(tree, id)
{
if (tree$node_id == id) {
return(tree);
}
#result <- c();
if (tree$caption != "TERMINAL")
{
l <- getNodeById(tree$left_child, id);
r <- getNodeById(tree$right_child ,id);
# slow solution
#result <- append(result,c(l,r));
result <- NULL
if (!is.null(l)) result <- l
if (!is.null(r)) result <- r
return(result);
} else{
return(NULL);
}
}
l <- lineprof(treeDivergence(forest$forest[[1]],forest$forest[[2]],forest$data))
l
a <- Sys.time()
D <- diversityMatrix(fr)
Sys.time()-a
set.seed(789)
require("semtree")
data(lgcm)
lgcm$agegroup <- as.ordered(lgcm$agegroup)
lgcm$training <- as.factor(lgcm$training)
lgcm$noise <- as.numeric(lgcm$noise)
# LOAD IN OPENMX MODEL.
# A SIMPLE LINEAR GROWTH MODEL WITH 5 TIME POINTS FROM SIMULATED DATA
manifests <- names(lgcm)[1:5]
lgcModel <- mxModel("Linear Growth Curve Model Path Specification",
type="RAM",
manifestVars=manifests,
latentVars=c("intercept","slope"),
# residual variances
mxPath(
from=manifests,
arrows=2,
free=TRUE,
values = c(1, 1, 1, 1, 1),
labels=c("residual1","residual2","residual3","residual4","residual5")
),
# latent variances and covariance
mxPath(
from=c("intercept","slope"),
connect="unique.pairs",
arrows=2,
free=TRUE,
values=c(1, 1, 1),
labels=c("vari", "cov", "vars")
),
# intercept loadings
mxPath(
from="intercept",
to=manifests,
arrows=1,
free=FALSE,
values=c(1, 1, 1, 1, 1)
),
# slope loadings
mxPath(
from="slope",
to=manifests,
arrows=1,
free=FALSE,
values=c(0, 1, 2, 3, 4)
),
# manifest means
mxPath(
from="one",
to=manifests,
arrows=1,
free=FALSE,
values=c(0, 0, 0, 0, 0)
),
# latent means
mxPath(
from="one",
to=c("intercept", "slope"),
arrows=1,
free=TRUE,
values=c(1, 1),
labels=c("meani", "means")
),
mxData(lgcm,type="raw")
)
fr <- semforest(lgcModel, lgcm,control = semforest.control(num.trees = 25))
vimp <- varimp(fr)
print(vimp)
print(vimp, na.omit=TRUE)
vimp2 <- varimp(fr, method="permutationInteraction")
a <- Sys.time()
D <- diversityMatrix(fr)
Sys.time()-a
library(lineprof) # via devtools::install_github("hadley/lineprof")
l <- lineprof(treeDivergence(forest$forest[[1]],forest$forest[[2]],forest$data))
l
l <- lineprof(treeDivergence(forest$forest[[1]],forest$forest[[2]],forest$data))
l
forest$forest[[1]]
forest$forest[[2]]
forest$forest[[4]]
forest$forest[[8]]
forest$forest[[10]]
forest$forest[[12]]
forest$forest[[13]]
l <- lineprof(treeDivergence(forest$forest[[10]],forest$forest[[13]],forest$data))
l
!NA
if (NA) TRUE else FALSE
N <- 100
P <- 100
data <- matrix( sample(c(0,1),N*P),nrow=N)
N <- 100
P <- 100
simdata <- matrix( sample(c(0,1),N*P),nrow=N)
N <- 100
P <- 100
simdata <- matrix( sample(c(0,1),N*P,TRUE),nrow=N)
simdata
cbind(x,simdata)
data.frame(cbind(x,simdata))
N <- 100
P <- 100
x <- rnorm(N)
simdata <- matrix( sample(c(0,1),N*P,TRUE),nrow=N)
simdata <- data.frame(cbind(x,simdata))
dim(simdata)
simdata
simdata$x
names(simdata)
names(simdata)[1] <- "X"
N <- 100
P <- 100
x <- rnorm(N)
simdata <- matrix( sample(c(0,1),N*P,TRUE),nrow=N)
simdata <- data.frame(cbind(x,simdata))
names(simdata)[1] <- "X"
#
# This model specification was automatically generated by Onyx
#
require("OpenMx");
modelData <- read.table(DATAFILENAME, header = TRUE)
manifests<-c("X")
latents<-c()
model <- mxModel("Unnamed_Model",
type="RAM",
manifestVars = manifests,
latentVars = latents,
mxPath(from="one",to=c("X"), free=c(TRUE), value=c(1.0) , arrows=1, label=c("const__X") ),
mxPath(from="X",to=c("X"), free=c(TRUE), value=c(1.0) , arrows=2, label=c("VAR_X") ),
mxData(modelData, type = "raw")
);
result <- mxRun(model)
summary(result)
require(semtree)
tree <- semtree(model, simdata)
simdata
names(simdata)
N <- 100
P <- 100
x <- rnorm(N)
simdata <- matrix( sample(c(0,1),N*P,TRUE),nrow=N)
simdata <- data.frame(cbind(x,simdata))
names(simdata)[1] <- "X"
#
# This model specification was automatically generated by Onyx
#
require("OpenMx");
manifests<-c("X")
latents<-c()
model <- mxModel("Unnamed_Model",
type="RAM",
manifestVars = manifests,
latentVars = latents,
mxPath(from="one",to=c("X"), free=c(TRUE), value=c(1.0) , arrows=1, label=c("const__X") ),
mxPath(from="X",to=c("X"), free=c(TRUE), value=c(1.0) , arrows=2, label=c("VAR_X") ),
mxData(modelData, type = "raw")
);
require(semtree)
tree <- semtree(model, simdata)
model@manifestVars
model <- mxModel("Unnamed_Model",
type="RAM",
manifestVars = manifests,
latentVars = latents,
mxPath(from="one",to=c("X"), free=c(TRUE), value=c(1.0) , arrows=1, label=c("const__X") ),
mxPath(from="X",to=c("X"), free=c(TRUE), value=c(1.0) , arrows=2, label=c("VAR_X") ),
mxData(modelData, type = "raw")
);
N <- 100
P <- 100
x <- rnorm(N)
simdata <- matrix( sample(c(0,1),N*P,TRUE),nrow=N)
simdata <- data.frame(cbind(x,simdata))
names(simdata)[1] <- "X"
#
# This model specification was automatically generated by Onyx
#
require("OpenMx");
manifests<-c("X")
latents<-c()
model <- mxModel("Unnamed_Model",
type="RAM",
manifestVars = manifests,
latentVars = latents,
mxPath(from="one",to=c("X"), free=c(TRUE), value=c(1.0) , arrows=1, label=c("const__X") ),
mxPath(from="X",to=c("X"), free=c(TRUE), value=c(1.0) , arrows=2, label=c("VAR_X") )
);
require(semtree)
tree <- semtree(model, simdata)
tree
N <- 100
P <- 10
x <- rnorm(N)
simdata <- matrix( sample(c(0,1),N*P,TRUE),nrow=N)
simdata <- data.frame(cbind(x,simdata))
names(simdata)[1] <- "X"
#
# This model specification was automatically generated by Onyx
#
require("OpenMx");
manifests<-c("X")
latents<-c()
model <- mxModel("Unnamed_Model",
type="RAM",
manifestVars = manifests,
latentVars = latents,
mxPath(from="one",to=c("X"), free=c(TRUE), value=c(1.0) , arrows=1, label=c("const__X") ),
mxPath(from="X",to=c("X"), free=c(TRUE), value=c(1.0) , arrows=2, label=c("VAR_X") )
);
require(semtree)
tree <- semtree(model, simdata,control = semtree.control(alpha = 1))
tree
N <- 500
P <- 10
x <- rnorm(N)
simdata <- matrix( sample(c(0,1),N*P,TRUE),nrow=N)
simdata <- data.frame(cbind(x,simdata))
names(simdata)[1] <- "X"
#
# This model specification was automatically generated by Onyx
#
require("OpenMx");
manifests<-c("X")
latents<-c()
model <- mxModel("Unnamed_Model",
type="RAM",
manifestVars = manifests,
latentVars = latents,
mxPath(from="one",to=c("X"), free=c(TRUE), value=c(1.0) , arrows=1, label=c("const__X") ),
mxPath(from="X",to=c("X"), free=c(TRUE), value=c(1.0) , arrows=2, label=c("VAR_X") )
);
require(semtree)
tree <- semtree(model, simdata,control = semtree.control(alpha = 1))
plot(tree)
traverse(tree, dataset = simdata)
tv <- traverse(tree, dataset = simdata)
test <- sim(N=5000)
tv <- traverse(tree, dataset = test)
sim <- function(N = 500, P = 10) {
x <- rnorm(N)
simdata <- matrix( sample(c(0,1),N*P,TRUE),nrow=N)
simdata <- data.frame(cbind(x,simdata))
names(simdata)[1] <- "X"
return(simdata)
}
test <- sim(N=5000)
tv <- traverse(tree, dataset = test)
tv
test <- sim(N=5000)
tv <- traverse(tree, dataset = test)
l <- lineprof(traverse(tree, dataset = test))
l
sine(l)
shine(l)
dataset <- test
apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
tree
apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree))
traverse.red <- semtree:::traverse.rec
traverse.rec <- semtree:::traverse.rec
apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree))
apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
test <- sim(N=50000)
a <- Sys.time()
tv <- traverse(tree, dataset = test)
test <- sim(N=5000)
a <- Sys.time()
tv <- traverse(tree, dataset = test)
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree
a3 <- Sys.time()
#l <- lineprof(tra
test <- sim(N=5000)
a <- Sys.time()
tv <- traverse(tree, dataset = test)
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
#l <- lineprof
a3-a2
a2-a1
a2-a1
a2-a
a2-a1
a3-a2
test <- sim(N=5000)
a <- Sys.time()
tv <- traverse(tree, dataset = test)
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
a2-a1
a3-a2
test <- sim(N=5000)
a1 <- Sys.time()
tv <- traverse(tree, dataset = test)
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
a2-a1
a3-a2
test <- sim(N=5000)
a1 <- Sys.time()
tv <- traverse(tree, dataset = test)
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
a2-a1
a3-a2
test <- sim(N=12000)
a1 <- Sys.time()
tv <- traverse(tree, dataset = test)
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
a2-a1
a3-a2
test <- sim(N=12000)
a1 <- Sys.time()
tv <- traverse(tree, dataset = test)
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
a2-a1
a3-a2
test <- sim(N=18000)
a1 <- Sys.time()
tv <- traverse(tree, dataset = test)
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
a2-a1
a3-a2
test <- sim(N=18000)
a1 <- Sys.time()
#tv <- traverse(tree, dataset = test)
result <- rep(NA, dim(dataset)[1])
for (i in 1:dim(dataset)[1]) {
result[i] <- traverse.rec(row = dataset[i,],tree = tree)
}
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
a2-a1
a3-a2
test <- sim(N=18000)
a1 <- Sys.time()
#tv <- traverse(tree, dataset = test)
result <- rep(NA, dim(dataset)[1])
for (i in 1:dim(dataset)[1]) {
result[i] <- traverse.rec(row = dataset[i,],tree = tree)
}
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
a2-a1
a3-a2
test <- sim(N=18000)
a1 <- Sys.time()
#tv <- traverse(tree, dataset = test)
result <- rep(NA, dim(dataset)[1])
for (i in 1:dim(dataset)[1]) {
result[i] <- traverse.rec(row = dataset[i,],tree = tree)
}
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
a2-a1
a3-a2
test <- sim(N=18000)
a1 <- Sys.time()
#tv <- traverse(tree, dataset = test)
result <- rep(NA, dim(dataset)[1])
for (i in 1:dim(dataset)[1]) {
result[i] <- traverse.rec(row = dataset[i,],tree = tree)
}
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
a2-a1
a3-a2
test <- sim(N=18000)
a1 <- Sys.time()
result <- rep(NA, dim(dataset)[1])
for (i in 1:dim(dataset)[1]) {
result[i] <- traverse.rec(row = dataset[i,],tree = tree)
}
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
tv <- traverse(tree, dataset = test)
a4
a2-a1
a3-a2
a4-a3
test <- sim(N=18000)
a1 <- Sys.time()
result <- rep(NA, dim(dataset)[1])
for (i in 1:dim(dataset)[1]) {
result[i] <- traverse.rec(row = dataset[i,],tree = tree)
}
a2 <- Sys.time()
tv2 <- apply(X=dataset,MARGIN=1, FUN=traverse.rec, tree)
a3 <- Sys.time()
tv <- traverse(tree, dataset = test)
a4 <- Sys.time()
a2-a1
a3-a2
a4-a3
